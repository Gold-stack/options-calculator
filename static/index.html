<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Options Profit Calculator</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“ˆ</text></svg>">

  <!-- React -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>

  <!-- PropTypes (fixes 'oneOfType' / animation prop-types issues) -->
  <script src="https://unpkg.com/prop-types@15/prop-types.min.js"></script>

  <!-- Recharts UMD (provides window.Recharts) -->
  <script src="https://cdn.jsdelivr.net/npm/recharts/umd/Recharts.min.js"></script>

  <!-- Babel (OK for prototyping; later replace with Vite build) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
    document.getElementById("root").innerHTML =
  "<div style='padding:16px;font-family:monospace;background:#111;color:#fff'>Babel script startedâ€¦</div>";
    // --- HARD ERROR OVERLAY (zeigt Fehler direkt im UI) ---
window.onerror = function (message, source, lineno, colno, error) {
  const msg = `ERROR: ${message}\n@ ${lineno}:${colno}\n${source || ""}`;
  console.error(msg, error);

  const root = document.getElementById("root");
  if (root) {
    root.innerHTML =
      `<div style="padding:16px;font-family:monospace;background:#300;color:#fff;white-space:pre-wrap">
${msg}

${(error && error.stack) ? error.stack : ""}
</div>`;
  }
};
    console.log("BABEL START OK");
    // ---- DEBUG (leave for now; remove later) ----
    console.log("BOOT", { React: typeof React, ReactDOM: typeof ReactDOM, Recharts: typeof Recharts });
    if (!window.React || !window.ReactDOM) throw new Error("React/ReactDOM not loaded");
if (!window.Recharts) throw new Error("Recharts not loaded (window.Recharts is undefined)");

    window.addEventListener("error", (e) => console.error("WINDOW ERROR:", e.message, e.error));
    window.addEventListener("unhandledrejection", (e) => console.error("PROMISE REJECTION:", e.reason));

    // API uses relative URL (same server)
    const API_BASE_URL = '/api';

    // Recharts comes from UMD global
    const {
      LineChart, Line, XAxis, YAxis, ReferenceLine,
      ResponsiveContainer, ComposedChart, Tooltip
   } = window.Recharts;

    // Black-Scholes
    const normalCDF = (x) => {
      const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
      const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
      const sign = x < 0 ? -1 : 1;
      x = Math.abs(x) / Math.sqrt(2);
      const t = 1.0 / (1.0 + p * x);
      const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
      return 0.5 * (1.0 + sign * y);
    };

    const blackScholes = (S, K, T, r, sigma, optionType) => {
      if (T <= 0) return optionType === 'call' ? Math.max(0, S - K) : Math.max(0, K - S);
      const d1 = (Math.log(S / K) + (r + sigma * sigma / 2) * T) / (sigma * Math.sqrt(T));
      const d2 = d1 - sigma * Math.sqrt(T);
      if (optionType === 'call') return S * normalCDF(d1) - K * Math.exp(-r * T) * normalCDF(d2);
      return K * Math.exp(-r * T) * normalCDF(-d2) - S * normalCDF(-d1);
    };

    const calculateGreeks = (S, K, T, r, sigma, optionType) => {
      if (T <= 0) return { delta: optionType === 'call' ? (S > K ? 1 : 0) : (S < K ? -1 : 0), gamma: 0, theta: 0, vega: 0 };
      const d1 = (Math.log(S / K) + (r + sigma * sigma / 2) * T) / (sigma * Math.sqrt(T));
      const d2 = d1 - sigma * Math.sqrt(T);
      const nd1 = Math.exp(-d1 * d1 / 2) / Math.sqrt(2 * Math.PI);
      return {
        delta: optionType === 'call' ? normalCDF(d1) : normalCDF(d1) - 1,
        gamma: nd1 / (S * sigma * Math.sqrt(T)),
        theta: (-(S * nd1 * sigma) / (2 * Math.sqrt(T)) - r * K * Math.exp(-r * T) * (optionType === 'call' ? normalCDF(d2) : normalCDF(-d2))) / 365,
        vega: S * nd1 * Math.sqrt(T) / 100
      };
    };

    const STRATEGIES = {
      'long-call': { name: 'Long Call', legs: [{ type: 'call', position: 'buy', strikeOffset: 0 }] },
      'long-put': { name: 'Long Put', legs: [{ type: 'put', position: 'buy', strikeOffset: 0 }] },
      'short-call': { name: 'Short Call', legs: [{ type: 'call', position: 'sell', strikeOffset: 0 }] },
      'short-put': { name: 'Short Put', legs: [{ type: 'put', position: 'sell', strikeOffset: 0 }] },
      'covered-call': { name: 'Covered Call', legs: [{ type: 'call', position: 'sell', strikeOffset: 5 }], includeStock: true },
      'bull-call-spread': { name: 'Bull Call Spread', legs: [{ type: 'call', position: 'buy', strikeOffset: 0 }, { type: 'call', position: 'sell', strikeOffset: 10 }] },
      'bear-put-spread': { name: 'Bear Put Spread', legs: [{ type: 'put', position: 'buy', strikeOffset: 0 }, { type: 'put', position: 'sell', strikeOffset: -10 }] },
      'straddle': { name: 'Long Straddle', legs: [{ type: 'call', position: 'buy', strikeOffset: 0 }, { type: 'put', position: 'buy', strikeOffset: 0 }] },
      'strangle': { name: 'Long Strangle', legs: [{ type: 'call', position: 'buy', strikeOffset: 5 }, { type: 'put', position: 'buy', strikeOffset: -5 }] },
      'iron-condor': { name: 'Iron Condor', legs: [
        { type: 'put', position: 'buy', strikeOffset: -15 },
        { type: 'put', position: 'sell', strikeOffset: -5 },
        { type: 'call', position: 'sell', strikeOffset: 5 },
        { type: 'call', position: 'buy', strikeOffset: 15 },
      ]},
      'butterfly': { name: 'Butterfly', legs: [
        { type: 'call', position: 'buy', strikeOffset: -10 },
        { type: 'call', position: 'sell', strikeOffset: 0, quantity: 2 },
        { type: 'call', position: 'buy', strikeOffset: 10 },
      ]},
      'custom': { name: 'Custom', legs: [] },
    };

    function OptionsProfitCalculator() {
      const [symbol, setSymbol] = React.useState('AAPL');
      const [symbolInput, setSymbolInput] = React.useState('AAPL');
      const [stockData, setStockData] = React.useState(null);
      const [stockPrice, setStockPrice] = React.useState(185);
      const [companyName, setCompanyName] = React.useState('');

      const [expirations, setExpirations] = React.useState([]);
      const [selectedExpiration, setSelectedExpiration] = React.useState('');
      const [optionChain, setOptionChain] = React.useState({ calls: [], puts: [] });
      const [daysToExpiry, setDaysToExpiry] = React.useState(30);

      const [loading, setLoading] = React.useState(false);
      const [error, setError] = React.useState(null);
      const [lastUpdated, setLastUpdated] = React.useState(null);

      const [strategy, setStrategy] = React.useState('long-call');
      const [iv, setIv] = React.useState(30);
      const [viewMode, setViewMode] = React.useState('chart');
      const [tableDisplayMode, setTableDisplayMode] = React.useState('absolute');
      const riskFreeRate = 5;

      const [legs, setLegs] = React.useState([
        { id: 1, type: 'call', position: 'buy', strike: 185, premium: 5.50, quantity: 1, iv: 30 }
      ]);

      const [includeStock, setIncludeStock] = React.useState(false);
      const [stockShares, setStockShares] = React.useState(100);

      const multiplier = 100;
      const T = daysToExpiry / 365;
      const sigma = iv / 100;
      const r = riskFreeRate / 100;

      const colors = {
        bg: '#0f1115',
        cardBg: '#16181f',
        cardBorder: '#1f222b',
        inputBg: '#0d0e12',
        text: '#e5e7eb',
        textMuted: '#9ca3af',
        textDim: '#6b7280',
        accent: '#6366f1',
        profit: '#00c853',
        loss: '#ff1744',
        strike: '#60a5fa',
        breakeven: '#fbbf24',
        today: '#a78bfa',
      };

      const fetchJSON = async (url) => {
        const res = await fetch(url);
        const txt = await res.text();
        try { return JSON.parse(txt); }
        catch (e) { throw new Error(`Non-JSON response from ${url}: ${txt.slice(0,200)}`); }
      };

      const fetchStockData = async (sym) => {
        try {
          setLoading(true);
          setError(null);
          const data = await fetchJSON(`${API_BASE_URL}/stock/${sym}`);
          if (data.error) throw new Error(data.error);
          setStockData(data);
          setStockPrice(Number(data.currentPrice) || 0);
          setCompanyName(data.name || '');
          setSymbol(sym.toUpperCase());
          setLastUpdated(new Date());
          return data;
        } catch (err) {
          setError(`Failed to fetch stock: ${err.message}`);
          return null;
        } finally {
          setLoading(false);
        }
      };

      const fetchExpirations = async (sym) => {
        try {
          const data = await fetchJSON(`${API_BASE_URL}/options/${sym}/expirations`);
          if (data.error) throw new Error(data.error);
          const exps = data.expirations || [];
          setExpirations(exps);
          if (exps.length > 0) setSelectedExpiration(exps[0]);
          return exps;
        } catch (err) {
          setError(`Failed to fetch expirations: ${err.message}`);
          return [];
        }
      };

      const fetchOptionChain = async (sym, expiration) => {
        if (!expiration) return null;
        try {
          setLoading(true);
          const data = await fetchJSON(`${API_BASE_URL}/options/${sym}/chain?expiration=${encodeURIComponent(expiration)}`);
          if (data.error) throw new Error(data.error);

          setOptionChain({ calls: data.calls || [], puts: data.puts || [] });
          setDaysToExpiry(Number(data.daysToExpiry) || 0);
          setStockPrice(Number(data.underlyingPrice) || stockPrice);
          setLastUpdated(new Date());

          const calls = data.calls || [];
          const atmCall = calls.find(c => Math.abs((c.strike || 0) - (data.underlyingPrice || 0)) < 5);
          if (atmCall?.impliedVolatility) setIv(Math.round(atmCall.impliedVolatility * 100));
          return data;
        } catch (err) {
          setError(`Failed to fetch chain: ${err.message}`);
          return null;
        } finally {
          setLoading(false);
        }
      };

      const loadSymbolData = async () => {
        const sym = (symbolInput || '').toUpperCase().trim();
        if (!sym) return;
        const stockResult = await fetchStockData(sym);
        if (stockResult) {
          const exps = await fetchExpirations(sym);
          if (exps.length > 0) await fetchOptionChain(sym, exps[0]);
        }
      };

      React.useEffect(() => {
        if (selectedExpiration && symbol) fetchOptionChain(symbol, selectedExpiration);
      }, [selectedExpiration]);

      React.useEffect(() => { loadSymbolData(); }, []);

      const findOptionPremium = (strike, type) => {
        const options = type === 'call' ? optionChain.calls : optionChain.puts;
        const option = options.find(o => Number(o.strike) === Number(strike));
        if (option) return (option.bid > 0 && option.ask > 0) ? (option.bid + option.ask) / 2 : option.lastPrice;
        return null;
      };

      const availableStrikes = React.useMemo(() => {
        const all = [...(optionChain.calls || []).map(c => c.strike), ...(optionChain.puts || []).map(p => p.strike)];
        return [...new Set(all.filter(x => typeof x === "number" || typeof x === "string").map(Number))].sort((a, b) => a - b);
      }, [optionChain]);

      const nearestStrike = (target) => {
        if (!availableStrikes || availableStrikes.length === 0) return target;
        return availableStrikes.reduce((prev, curr) =>
          Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev
        );
      };

      const applyStrategy = (strategyKey) => {
        setStrategy(strategyKey);
        const template = STRATEGIES[strategyKey];
        if (!template || strategyKey === 'custom') return;

        const newLegs = template.legs.map((leg, i) => {
          const targetStrike = stockPrice + (leg.strikeOffset || 0);
          const closestStrike = nearestStrike(targetStrike);
          const premium = findOptionPremium(closestStrike, leg.type) || blackScholes(stockPrice, closestStrike, T, r, sigma, leg.type);
          return {
            id: i + 1,
            type: leg.type,
            position: leg.position,
            strike: closestStrike,
            premium: Math.round(premium * 100) / 100,
            quantity: leg.quantity || 1,
            iv: iv
          };
        });

        setLegs(newLegs);
        setIncludeStock(!!template.includeStock);
      };

      const calculatePL = (price, daysRemaining) => {
        const timeToExpiry = daysRemaining / 365;
        let totalPL = 0;

        (legs || []).forEach(leg => {
          const legSigma = (leg.iv || iv) / 100;
          const currentValue = blackScholes(price, leg.strike, timeToExpiry, r, legSigma, leg.type);
          const pl = leg.position === 'buy'
            ? (currentValue - leg.premium) * leg.quantity * multiplier
            : (leg.premium - currentValue) * leg.quantity * multiplier;
          totalPL += pl;
        });

        if (includeStock) totalPL += (price - stockPrice) * stockShares;
        return totalPL;
      };

      const metrics = React.useMemo(() => {
        const prices = [];
        for (let p = stockPrice * 0.5; p <= stockPrice * 1.5; p += 0.5) prices.push(p);

        const plAtExpiry = prices.map(p => calculatePL(p, 0));
        const maxProfit = Math.max(...plAtExpiry);
        const maxLoss = Math.min(...plAtExpiry);

        const breakevens = [];
        for (let i = 1; i < prices.length; i++) {
          if ((plAtExpiry[i-1] < 0 && plAtExpiry[i] >= 0) || (plAtExpiry[i-1] >= 0 && plAtExpiry[i] < 0)) {
            breakevens.push(prices[i-1] + (0 - plAtExpiry[i-1]) * (prices[i] - prices[i-1]) / (plAtExpiry[i] - plAtExpiry[i-1]));
          }
        }

        let totalPremium = 0;
        (legs || []).forEach(leg => {
          totalPremium += leg.position === 'buy'
            ? -leg.premium * leg.quantity * multiplier
            :  leg.premium * leg.quantity * multiplier;
        });

        return {
          maxProfit: maxProfit > 100000 ? 'Unlimited' : maxProfit,
          maxLoss:   maxLoss < -100000 ? 'Unlimited' : maxLoss,
          breakevens,
          totalPremium
        };
      }, [legs, stockPrice, includeStock, stockShares, iv]);

      const tableData = React.useMemo(() => {
        const prices = [];
        const step = stockPrice * 0.05;
        for (let p = stockPrice * 0.7; p <= stockPrice * 1.3; p += step) prices.push(parseFloat(p.toFixed(2)));

        const dates = [0];
        if (daysToExpiry > 7)  dates.unshift(Math.floor(daysToExpiry / 4));
        if (daysToExpiry > 14) dates.unshift(Math.floor(daysToExpiry / 2));
        if (daysToExpiry > 21) dates.unshift(Math.floor(daysToExpiry * 3 / 4));
        dates.unshift(daysToExpiry);

        return { prices, dates };
      }, [stockPrice, daysToExpiry]);

      const chartData = React.useMemo(() => {
        const points = [];
        const minPrice = stockPrice * 0.7, maxPrice = stockPrice * 1.3, step = (maxPrice - minPrice) / 60;
        for (let price = minPrice; price <= maxPrice; price += step) {
          points.push({
            price: parseFloat(price.toFixed(2)),
            atExpiry: calculatePL(price, 0),
            today: calculatePL(price, daysToExpiry)
          });
        }
        return points;
      }, [stockPrice, daysToExpiry, legs, includeStock, stockShares, iv]);

      const totalGreeks = React.useMemo(() => {
        let delta = 0, gamma = 0, theta = 0, vega = 0;

        (legs || []).forEach(leg => {
          const greeks = calculateGreeks(stockPrice, leg.strike, T, r, (leg.iv || iv) / 100, leg.type);
          const mult = (leg.position === 'buy' ? 1 : -1) * leg.quantity;
          delta += greeks.delta * mult * multiplier;
          gamma += greeks.gamma * mult * multiplier;
          theta += greeks.theta * mult * multiplier;
          vega  += greeks.vega  * mult * multiplier;
        });

        if (includeStock) delta += stockShares;
        return { delta, gamma, theta, vega };
      }, [legs, stockPrice, T, r, iv, includeStock, stockShares]);

      const formatCurrency = (value) => {
        if (value === 'Unlimited') return 'âˆž';
        if (typeof value !== 'number') return value;
        return (value >= 0 ? '+' : '') + new Intl.NumberFormat('en-US', {
          style: 'currency', currency: 'USD',
          minimumFractionDigits: 0, maximumFractionDigits: 0
        }).format(value);
      };

      const updateLeg = (id, field, value) => {
        setLegs((legs || []).map(l => {
          if (l.id === id) {
            const updated = { ...l, [field]: value };
            if (field === 'strike' || field === 'type') {
              const prem = findOptionPremium(field === 'strike' ? value : l.strike, field === 'type' ? value : l.type);
              if (prem) updated.premium = Math.round(prem * 100) / 100;
            }
            return updated;
          }
          return l;
        }));
        setStrategy('custom');
      };

      const addLeg = () => {
        const newId = Math.max(...(legs || []).map(l => l.id), 0) + 1;
        const defaultStrike = nearestStrike(stockPrice);
        setLegs([...(legs || []), { id: newId, type: 'call', position: 'buy', strike: defaultStrike, premium: 5, quantity: 1, iv }]);
        setStrategy('custom');
      };

      const removeLeg = (id) => {
        if ((legs || []).length <= 1) return;
        setLegs((legs || []).filter(l => l.id !== id));
        setStrategy('custom');
      };

      // Table heatmap helper
      const getHeatmapStyle = (pl, minPL, maxPL) => {
        if (Math.abs(pl) < 5) return { bg: 'transparent', text: colors.textMuted };
        if (pl > 0) {
          const ratio = Math.min(pl / (maxPL || 1), 1);
          return { bg: `rgba(34, 197, 94, ${0.08 + ratio * 0.22})`, text: `hsl(142, 76%, ${70 - ratio * 30}%)` };
        } else {
          const ratio = Math.min(Math.abs(pl) / (Math.abs(minPL) || 1), 1);
          const hue = 12 - ratio * 12;
          return { bg: `hsla(${hue}, ${75 + ratio * 15}%, 50%, ${0.1 + ratio * 0.2})`, text: `hsl(${hue}, ${75 + ratio * 15}%, ${68 - ratio * 23}%)` };
        }
      };

      const totalCost = Math.abs(metrics.totalPremium);

      return (
        <div style={{ minHeight: '100vh', background: colors.bg, color: colors.text, fontFamily: "'Inter', -apple-system, sans-serif", padding: '24px' }}>
          <div style={{ maxWidth: '1400px', margin: '0 auto' }}>

            {/* Header */}
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '24px', paddingBottom: '16px', borderBottom: `1px solid ${colors.cardBorder}` }}>
              <div>
                <h1 style={{ fontSize: '20px', fontWeight: '600', margin: 0 }}>Options Profit Calculator</h1>
                <p style={{ margin: '4px 0 0', fontSize: '12px', color: colors.textDim }}>
                  Real-time data from Yahoo Finance â€¢ {lastUpdated ? `Updated ${lastUpdated.toLocaleTimeString()}` : 'Loading...'}
                </p>
              </div>
              <div style={{ display: 'flex', gap: '8px' }}>
                {['chart', 'table'].map(mode => (
                  <button
                    key={mode}
                    onClick={() => setViewMode(mode)}
                    style={{
                      padding: '6px 12px',
                      background: viewMode === mode ? colors.accent : 'transparent',
                      border: `1px solid ${viewMode === mode ? colors.accent : colors.cardBorder}`,
                      borderRadius: '4px',
                      color: viewMode === mode ? '#fff' : colors.textMuted,
                      fontSize: '12px',
                      fontWeight: '500',
                      cursor: 'pointer',
                      textTransform: 'capitalize'
                    }}
                  >
                    {mode}
                  </button>
                ))}
              </div>
            </div>

            {error && (
              <div style={{ background: 'rgba(255, 23, 68, 0.1)', border: '1px solid rgba(255, 23, 68, 0.3)', borderRadius: '6px', padding: '12px 16px', marginBottom: '16px', color: colors.loss, fontSize: '13px' }}>
                {error}
              </div>
            )}

            <div style={{ display: 'grid', gridTemplateColumns: '320px 1fr', gap: '20px' }}>

              {/* Left Panel */}
              <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>

                {/* Symbol */}
                <div style={{ background: colors.cardBg, border: `1px solid ${colors.cardBorder}`, borderRadius: '8px', padding: '16px' }}>
                  <div style={{ fontSize: '11px', color: colors.textDim, textTransform: 'uppercase', marginBottom: '12px' }}>Stock Symbol</div>
                  <div style={{ display: 'flex', gap: '8px' }}>
                    <input
                      value={symbolInput}
                      onChange={(e) => setSymbolInput(e.target.value.toUpperCase())}
                      onKeyDown={(e) => e.key === 'Enter' && loadSymbolData()}
                      placeholder="AAPL"
                      style={{
                        flex: 1, padding: '10px 12px', background: colors.inputBg,
                        border: `1px solid ${colors.cardBorder}`, borderRadius: '4px',
                        color: colors.text, fontSize: '14px', fontWeight: '600', outline: 'none'
                      }}
                    />
                    <button
                      onClick={loadSymbolData}
                      disabled={loading}
                      style={{
                        padding: '10px 16px', background: colors.accent, border: 'none',
                        borderRadius: '4px', color: '#fff', fontSize: '13px', fontWeight: '500',
                        cursor: loading ? 'wait' : 'pointer', opacity: loading ? 0.7 : 1
                      }}
                    >
                      {loading ? '...' : 'Load'}
                    </button>
                  </div>

                  {stockData && (
                    <div style={{ marginTop: '12px', padding: '10px', background: colors.inputBg, borderRadius: '4px' }}>
                      <div style={{ fontSize: '14px', fontWeight: '600' }}>{companyName}</div>
                      <div style={{ display: 'flex', alignItems: 'baseline', gap: '8px', marginTop: '4px' }}>
                        <span style={{ fontSize: '20px', fontWeight: '700' }}>${Number(stockPrice || 0).toFixed(2)}</span>
                        <span style={{ fontSize: '13px', fontWeight: '500', color: (stockData.change || 0) >= 0 ? colors.profit : colors.loss }}>
                          {(stockData.change || 0) >= 0 ? '+' : ''}{Number(stockData.change || 0).toFixed(2)} ({Number(stockData.changePercent || 0).toFixed(2)}%)
                        </span>
                      </div>
                    </div>
                  )}
                </div>

                {/* Expiration */}
                <div style={{ background: colors.cardBg, border: `1px solid ${colors.cardBorder}`, borderRadius: '8px', padding: '16px' }}>
                  <div style={{ fontSize: '11px', color: colors.textDim, textTransform: 'uppercase', marginBottom: '12px' }}>Expiration</div>
                  <select
                    value={selectedExpiration}
                    onChange={(e) => setSelectedExpiration(e.target.value)}
                    style={{
                      width: '100%', padding: '10px', background: colors.inputBg,
                      border: `1px solid ${colors.cardBorder}`, borderRadius: '4px',
                      color: colors.text, fontSize: '13px', outline: 'none'
                    }}
                  >
                    {expirations.length === 0 && <option value="">Loading...</option>}
                    {expirations.map(exp => {
                      const days = Math.ceil((new Date(exp) - new Date()) / 86400000);
                      return <option key={exp} value={exp}>{exp} ({days}d)</option>;
                    })}
                  </select>
                </div>

                {/* Strategy */}
                <div style={{ background: colors.cardBg, border: `1px solid ${colors.cardBorder}`, borderRadius: '8px', padding: '16px' }}>
                  <div style={{ fontSize: '11px', color: colors.textDim, textTransform: 'uppercase', marginBottom: '12px' }}>Strategy</div>
                  <select
                    value={strategy}
                    onChange={(e) => applyStrategy(e.target.value)}
                    style={{
                      width: '100%', padding: '10px', background: colors.inputBg,
                      border: `1px solid ${colors.cardBorder}`, borderRadius: '4px',
                      color: colors.text, fontSize: '13px', outline: 'none'
                    }}
                  >
                    <optgroup label="Basic">
                      <option value="long-call">Long Call</option>
                      <option value="long-put">Long Put</option>
                      <option value="short-call">Short Call</option>
                      <option value="short-put">Short Put</option>
                      <option value="covered-call">Covered Call</option>
                    </optgroup>
                    <optgroup label="Spreads">
                      <option value="bull-call-spread">Bull Call Spread</option>
                      <option value="bear-put-spread">Bear Put Spread</option>
                    </optgroup>
                    <optgroup label="Advanced">
                      <option value="straddle">Long Straddle</option>
                      <option value="strangle">Long Strangle</option>
                      <option value="iron-condor">Iron Condor</option>
                      <option value="butterfly">Butterfly</option>
                    </optgroup>
                    <optgroup label="Custom">
                      <option value="custom">Custom</option>
                    </optgroup>
                  </select>
                </div>

                {/* Legs */}
                <div style={{ background: colors.cardBg, border: `1px solid ${colors.cardBorder}`, borderRadius: '8px', padding: '16px' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '12px' }}>
                    <div style={{ fontSize: '11px', color: colors.textDim, textTransform: 'uppercase' }}>Legs ({legs.length})</div>
                    <button onClick={addLeg} style={{ padding: '4px 10px', background: 'transparent', border: `1px solid ${colors.cardBorder}`, borderRadius: '4px', color: colors.textMuted, fontSize: '11px', cursor: 'pointer' }}>+ Add</button>
                  </div>

                  {legs.map((leg, idx) => (
                    <div key={leg.id} style={{ background: colors.inputBg, border: `1px solid ${colors.cardBorder}`, borderRadius: '6px', padding: '12px', marginBottom: '8px' }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '8px' }}>
                        <span style={{ fontSize: '11px', color: colors.textDim }}>Leg {idx + 1}</span>
                        {legs.length > 1 && (
                          <button onClick={() => removeLeg(leg.id)} style={{ background: 'transparent', border: 'none', color: colors.loss, cursor: 'pointer', fontSize: '16px' }}>Ã—</button>
                        )}
                      </div>

                      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '8px' }}>
                        <select
                          value={leg.position}
                          onChange={(e) => updateLeg(leg.id, 'position', e.target.value)}
                          style={{
                            padding: '6px', background: colors.cardBg, border: `1px solid ${colors.cardBorder}`,
                            borderRadius: '4px', color: leg.position === 'buy' ? colors.profit : colors.loss,
                            fontSize: '12px', outline: 'none'
                          }}
                        >
                          <option value="buy">Buy</option>
                          <option value="sell">Sell</option>
                        </select>

                        <select
                          value={leg.type}
                          onChange={(e) => updateLeg(leg.id, 'type', e.target.value)}
                          style={{
                            padding: '6px', background: colors.cardBg, border: `1px solid ${colors.cardBorder}`,
                            borderRadius: '4px', color: colors.text, fontSize: '12px', outline: 'none'
                          }}
                        >
                          <option value="call">Call</option>
                          <option value="put">Put</option>
                        </select>

                        <div>
                          <div style={{ fontSize: '10px', color: colors.textDim }}>Strike</div>
                          <select
                            value={leg.strike}
                            onChange={(e) => updateLeg(leg.id, 'strike', parseFloat(e.target.value))}
                            style={{
                              width: '100%', padding: '6px', background: colors.cardBg, border: `1px solid ${colors.cardBorder}`,
                              borderRadius: '4px', color: colors.text, fontSize: '12px', outline: 'none'
                            }}
                          >
                            {availableStrikes.map(s => <option key={s} value={s}>${s}</option>)}
                            {availableStrikes.length === 0 && <option value={leg.strike}>${leg.strike}</option>}
                          </select>
                        </div>

                        <div>
                          <div style={{ fontSize: '10px', color: colors.textDim }}>Premium</div>
                          <input
                            type="number"
                            value={leg.premium}
                            onChange={(e) => updateLeg(leg.id, 'premium', parseFloat(e.target.value) || 0)}
                            step={0.05}
                            style={{
                              width: '100%', padding: '6px', background: colors.cardBg, border: `1px solid ${colors.cardBorder}`,
                              borderRadius: '4px', color: colors.text, fontSize: '12px', outline: 'none'
                            }}
                          />
                        </div>
                      </div>

                      <div style={{ marginTop: '8px' }}>
                        <div style={{ fontSize: '10px', color: colors.textDim }}>Contracts</div>
                        <input
                          type="number"
                          value={leg.quantity}
                          onChange={(e) => updateLeg(leg.id, 'quantity', parseInt(e.target.value) || 1)}
                          min={1}
                          style={{
                            width: '100%', padding: '6px', background: colors.cardBg, border: `1px solid ${colors.cardBorder}`,
                            borderRadius: '4px', color: colors.text, fontSize: '12px', outline: 'none'
                          }}
                        />
                      </div>
                    </div>
                  ))}

                  <div style={{ marginTop: '12px', padding: '10px', background: colors.inputBg, borderRadius: '4px' }}>
                    <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer', fontSize: '12px', color: colors.textMuted }}>
                      <input type="checkbox" checked={includeStock} onChange={(e) => setIncludeStock(e.target.checked)} style={{ accentColor: colors.accent }} />
                      Include stock ({stockShares} shares)
                    </label>
                  </div>
                </div>

              </div>

              {/* Right Panel */}
              <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>

                {/* Metrics */}
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(5, 1fr)', gap: '12px' }}>
                  {[
                    { label: 'Max Profit', value: metrics.maxProfit, color: colors.profit },
                    { label: 'Max Loss', value: metrics.maxLoss, color: colors.loss },
                    { label: 'Break-even', value: metrics.breakevens[0] ? `$${metrics.breakevens[0].toFixed(2)}` : 'N/A', color: colors.breakeven },
                    { label: 'Net Premium', value: metrics.totalPremium, color: (metrics.totalPremium || 0) >= 0 ? colors.profit : colors.loss },
                    { label: 'Days Left', value: daysToExpiry, color: colors.textMuted },
                  ].map(m => (
                    <div key={m.label} style={{ background: colors.cardBg, border: `1px solid ${colors.cardBorder}`, borderRadius: '6px', padding: '12px' }}>
                      <div style={{ fontSize: '10px', color: colors.textDim, marginBottom: '4px', textTransform: 'uppercase' }}>{m.label}</div>
                      <div style={{ fontSize: '16px', fontWeight: '600', color: m.color, fontFamily: 'monospace' }}>
                        {typeof m.value === 'number' ? formatCurrency(m.value) : m.value}
                      </div>
                    </div>
                  ))}
                </div>

                {/* Greeks */}
                <div style={{ background: colors.cardBg, border: `1px solid ${colors.cardBorder}`, borderRadius: '8px', padding: '14px 16px', display: 'flex', gap: '24px' }}>
                  <div style={{ fontSize: '11px', color: colors.textDim, textTransform: 'uppercase' }}>Greeks</div>
                  {[
                    { l: 'Delta', v: totalGreeks.delta.toFixed(1) },
                    { l: 'Gamma', v: totalGreeks.gamma.toFixed(3) },
                    { l: 'Theta', v: totalGreeks.theta.toFixed(1) },
                    { l: 'Vega',  v: totalGreeks.vega.toFixed(1)  }
                  ].map(g => (
                    <div key={g.l} style={{ display: 'flex', gap: '6px' }}>
                      <span style={{ fontSize: '12px', color: colors.textMuted }}>{g.l}</span>
                      <span style={{ fontSize: '13px', fontWeight: '500', fontFamily: 'monospace' }}>{g.v}</span>
                    </div>
                  ))}
                </div>

                {/* Chart / Table */}
                <div style={{ background: colors.cardBg, border: `1px solid ${colors.cardBorder}`, borderRadius: '8px', padding: '20px', flex: 1, minHeight: '400px' }}>
                  {viewMode === 'chart' ? (
                    <>
                      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '16px' }}>
                        <div style={{ fontSize: '13px', color: colors.textMuted }}>P/L by Stock Price</div>
                        <div style={{ fontSize: '11px', color: colors.textDim }}>
                          <span style={{ color: colors.text }}>â€”</span> Expiry &nbsp;
                          <span style={{ color: colors.today }}>--</span> Today
                        </div>
                      </div>

                      <div style={{ height: '350px' }}>
                        <ResponsiveContainer width="100%" height="100%">
                          <ComposedChart data={chartData} margin={{ top: 20, right: 30, left: 20, bottom: 20 }}>
                            <XAxis dataKey="price" stroke={colors.cardBorder} tick={{ fill: colors.textDim, fontSize: 10 }} tickFormatter={v => `$${v}`} />
                            <YAxis stroke={colors.cardBorder} tick={{ fill: colors.textDim, fontSize: 10 }} tickFormatter={v => `$${Math.round(v)}`} />
                            <ReferenceLine y={0} stroke={colors.textDim} strokeOpacity={0.3} />
                            <ReferenceLine x={stockPrice} stroke={colors.strike} strokeOpacity={0.5} strokeDasharray="4 4" />
                            {(metrics.breakevens || []).map((be, i) => (
                              <ReferenceLine key={i} x={be} stroke={colors.breakeven} strokeOpacity={0.5} strokeDasharray="4 4" />
                            ))}
                            <Tooltip
                              contentStyle={{ background: colors.cardBg, border: `1px solid ${colors.cardBorder}`, borderRadius: '4px', fontSize: '12px' }}
                              formatter={(v) => formatCurrency(v)}
                            />
                            <Line type="monotone" dataKey="atExpiry" name="At Expiry" stroke={colors.text} strokeWidth={2} dot={false} />
                            <Line type="monotone" dataKey="today" name="Today" stroke={colors.today} strokeWidth={1.5} dot={false} strokeDasharray="4 4" />
                          </ComposedChart>
                        </ResponsiveContainer>
                      </div>
                    </>
                  ) : (
                    (() => {
                      let minPL = 0, maxPL = 0;
                      tableData.prices.forEach(p => tableData.dates.forEach(d => {
                        const pl = calculatePL(p, d);
                        if (pl < minPL) minPL = pl;
                        if (pl > maxPL) maxPL = pl;
                      }));

                      const formatVal = (pl, mode) => {
                        if (mode === 'percent') {
                          if (totalCost === 0) return 'â€”';
                          const pct = (pl / totalCost * 100);
                          return `${pl >= 0 ? '+' : ''}${pct.toFixed(0)}%`;
                        }
                        return `${pl >= 0 ? '+' : ''}${Math.round(pl).toLocaleString()}`;
                      };

                      return (
                        <>
                          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                              <div style={{ fontSize: '13px', color: colors.textMuted }}>P/L Table</div>
                              <div style={{ display: 'flex', background: colors.inputBg, borderRadius: '6px', padding: '3px', border: `1px solid ${colors.cardBorder}` }}>
                                {[{ k: 'absolute', l: '$' }, { k: 'percent', l: '%' }].map(o => (
                                  <button
                                    key={o.k}
                                    onClick={() => setTableDisplayMode(o.k)}
                                    style={{
                                      padding: '4px 12px',
                                      background: tableDisplayMode === o.k ? colors.cardBorder : 'transparent',
                                      border: 'none',
                                      borderRadius: '4px',
                                      color: tableDisplayMode === o.k ? colors.text : colors.textDim,
                                      fontSize: '12px',
                                      fontWeight: '600',
                                      cursor: 'pointer'
                                    }}
                                  >
                                    {o.l}
                                  </button>
                                ))}
                              </div>
                            </div>
                          </div>

                          <div style={{ overflowX: 'auto', borderRadius: '8px', border: `1px solid ${colors.cardBorder}` }}>
                            <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '12px' }}>
                              <thead>
                                <tr style={{ background: colors.inputBg }}>
                                  <th style={{ padding: '12px 16px', textAlign: 'left', color: colors.textMuted, fontWeight: '500', fontSize: '11px', borderBottom: `1px solid ${colors.cardBorder}` }}>Stock</th>
                                  {tableData.dates.map(d => (
                                    <th key={d} style={{ padding: '12px 16px', textAlign: 'right', color: colors.textMuted, fontWeight: '500', fontSize: '11px', borderBottom: `1px solid ${colors.cardBorder}` }}>
                                      {d === 0 ? 'Expiry' : `${d}d`}
                                    </th>
                                  ))}
                                </tr>
                              </thead>
                              <tbody>
                                {tableData.prices.map((price) => {
                                  const isCurrent = Math.abs(price - stockPrice) < stockPrice * 0.026;
                                  return (
                                    <tr key={price}>
                                      <td style={{
                                        padding: '10px 16px',
                                        color: isCurrent ? colors.text : colors.textDim,
                                        fontWeight: isCurrent ? '600' : '400',
                                        fontFamily: 'monospace',
                                        fontSize: '12px',
                                        borderBottom: `1px solid ${colors.cardBorder}`,
                                        background: isCurrent ? 'rgba(96,165,250,0.1)' : 'transparent'
                                      }}>
                                        ${price.toFixed(0)}
                                      </td>

                                      {tableData.dates.map(d => {
                                        const pl = calculatePL(price, d);
                                        const style = getHeatmapStyle(pl, minPL, maxPL);
                                        return (
                                          <td key={d} style={{
                                            padding: '10px 16px',
                                            textAlign: 'right',
                                            fontFamily: 'monospace',
                                            fontSize: '12px',
                                            fontWeight: '500',
                                            background: style.bg,
                                            color: style.text,
                                            borderBottom: `1px solid ${colors.cardBorder}`
                                          }}>
                                            {formatVal(pl, tableDisplayMode)}
                                          </td>
                                        );
                                      })}
                                    </tr>
                                  );
                                })}
                              </tbody>
                            </table>
                          </div>
                        </>
                      );
                    })()
                  )}
                </div>

                {/* Position Summary */}
                <div style={{ background: colors.cardBg, border: `1px solid ${colors.cardBorder}`, borderRadius: '6px', padding: '12px 16px', display: 'flex', flexWrap: 'wrap', gap: '12px', alignItems: 'center', fontSize: '12px' }}>
                  <span style={{ color: colors.textDim }}>Position:</span>
                  {legs.map((leg, i) => (
                    <span key={leg.id} style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                      {i > 0 && <span style={{ color: colors.textDim }}>+</span>}
                      <span style={{
                        padding: '2px 6px',
                        background: leg.position === 'buy' ? 'rgba(0,200,83,0.1)' : 'rgba(255,23,68,0.1)',
                        border: `1px solid ${leg.position === 'buy' ? 'rgba(0,200,83,0.3)' : 'rgba(255,23,68,0.3)'}`,
                        borderRadius: '3px',
                        color: leg.position === 'buy' ? colors.profit : colors.loss,
                        fontSize: '10px',
                        fontWeight: '600'
                      }}>
                        {leg.position === 'buy' ? 'BUY' : 'SELL'}
                      </span>
                      <span style={{ color: colors.textMuted }}>
                        {leg.quantity}Ã— {leg.type.toUpperCase()} ${leg.strike} @ ${Number(leg.premium).toFixed(2)}
                      </span>
                    </span>
                  ))}
                  {includeStock && <span style={{ color: colors.textMuted }}>+ {stockShares} shares</span>}
                </div>

              </div>
            </div>
          </div>

          <style>{`
            * { box-sizing: border-box; }
            input, select { outline: none; font-family: inherit; }
            input[type="number"]::-webkit-inner-spin-button,
            input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; }
            input[type="number"] { -moz-appearance: textfield; }
            select option { background: #16181f; }
            ::-webkit-scrollbar { width: 8px; height: 8px; }
            ::-webkit-scrollbar-track { background: #0f1115; }
            ::-webkit-scrollbar-thumb { background: #1f222b; border-radius: 4px; }
          `}</style>
        </div>
      );
    }

    console.log("RENDERING APP");
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<OptionsProfitCalculator />);
  </script>
</body>
</html>
